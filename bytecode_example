//var a = import "test";
//var b = 1;
//var t = function(toto: int) : int { var a = toto + 2; var dummy = a; return dummy; };
//var c = 5 * a.get() + b;
//var result = t(c);
//var object = function() : var { return { titi : function(test: int) {} }; };
//object.titi(result);


//After bytecode compilation (unoptimized) :
//(And we could add type information)

script test            | register = test : script-link
in  a                  | symbol a = test : script-link  
out 1                  | register : int
in  b                  | symbol b : int

//WARNING : that jump length can only be deduced after bytecode generation (so in a second pass)
jump 8                 | EP += function t bytecode length (= BP(t) = 8)
label t                | symbol t = BP : function; "push" the bytecode context for naming local variables : t
    pop                | register pop stack : int
    in toto            | symbol t_toto : int
    add 2              | add 2 : int to the register
    in a               | symbol t_a : int
    in dummy
    out dummy
    end                | register is preserved; EP = pop ESP

//a.get()
out a
field get              | symbol a_get = access symbol get in "a" instance
jump                   | ESP push current register value; EP = ESP back

// * 5
mul 5
// + b
add b

//c =
in c

//push c
out c
push 

//call t(c)
out t
jump t

//result =
in result

label object
    label titi
        pop
        in test
        end
    end

out object
field titi
in tmp_object_titi

out result
push

jump tmp_object_titi


//////////////////////////////////////////////////////////////////////
//NOTES

//Common things :
//Register : stores a temp value

//Execution related things :
//Bytecode
//ESP = Execution stack pointer (= a stack of pointers to Bytecode)
//EP = Current execution pointer

//Generation related things :
//BP = Bytecode pointer (while bytecode generation phase only)
//Symbol table

//Memory related things :
//Memory table
//Stack
//Script-link

/////////////////////////////////////////////////////////////////////
//Commands list (known)
//set
//in
//out
//push
//pop
//label
//jump
//field
//script 
//end
//mul
//add
//div
//sub


///////////////////////////////////////////////////////////////////
//Types
//Native   C++
///////////////////
//int      (int)
//float    (double)
//string   (SharedString (using shared_ptr))
//function (bytecode op relative address, so std::size_t, and variable name OR in case of bridging, shared_ptr to std::function)
//object   (variable name in bytecode memory)

